function parse_git_dirty {
  [[ $(git status 2> /dev/null | tail -n1) != "nothing to commit (working directory clean)" ]] && echo "*" 
}
function parse_git_branch {
    git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/[\1$(parse_git_dirty)]/"
}

set -o vi

export PATH=/usr/local/bin:$PATH:$EC2_HOME/bin:/usr/local/sbin:~/bin:/Users/Owen/scala/bin:/opt/node/bin
export PS1='\[\e[33m\]\w\e[32m\]$(parse_git_branch) $\[\e[0m\] '
export EDITOR=/usr/bin/vim

export CC=/usr/bin/gcc-4.2

#=====MAKE LS COLOR MORE AESTHETICALLY PLEASING=====
export CLICOLOR=1
export LSCOLORS=DxGxcxdxCxegedabagacad

#=====AUTO-COMPLETION FOR GIT BRANCHES=====
source ~/.git-completion.bash

alias ls='ls -GA'
alias ll='ls -GAl'

alias gl='git l'
alias gs='git s'
alias go='git o'
alias gc='git c -m'
alias ga='git rm-a && git a .'
alias gb='git b -r'
alias gd='git d'
alias g='git'
alias gpush='git push'
alias gpull='git pull'
alias gstash='git stash'
alias gpop='git stash pop'

alias m1='alias g1="cd `pwd`"'
alias m2='alias g2="cd `pwd`"'
alias m3='alias g3="cd `pwd`"'
alias m4='alias g4="cd `pwd`"'
alias m5='alias g5="cd `pwd`"'
alias m6='alias g6="cd `pwd`"'
alias m7='alias g7="cd `pwd`"'
alias m8='alias g8="cd `pwd`"'
alias m9='alias g9="cd `pwd`"'
alias mdump='alias|grep -e "alias g[0-9]"|grep -v "alias m" > ~/.bookmarks'
alias mlist='alias | grep -e "alias g[0-9]"|grep -v "alias m"|sed "s/alias //"'
source ~/.bookmarks

alias ec2='ssh -i ~/.ec2/owen.pem ec2-user@ec2-54-234-179-108.compute-1.amazonaws.com'
alias ece='ssh f57wang@ecelinux.uwaterloo.ca -X'
alias loo='ssh f57wang@sftp.eng.uwaterloo.ca -X'
alias tmux='TERM=xterm-256color tmux'

#=====AUTO-COMPLETION FOR ALIASES=====

# wrap_alias takes three arguments:
# $1: The name of the alias
# $2: The command used in the alias
# $3: The arguments in the alias all in one string
# Generate a wrapper completion function (completer) for an alias
# based on the command and the given arguments, if there is a
# completer for the command, and set the wrapper as the completer for
# the alias.
function wrap_alias() {
  [[ "$#" == 3 ]] || return 1

  local alias_name="$1"
  local aliased_command="$2"
  local alias_arguments="$3"
  local num_alias_arguments=$(echo "$alias_arguments" | wc -w)

  # The completion currently being used for the aliased command.
  local completion=$(complete -p $aliased_command 2> /dev/null)

  # Only a completer based on a function can be wrapped so look for -F
  # in the current completion. This check will also catch commands
  # with no completer for which $completion will be empty.
  echo $completion | grep -q -- -F || return 0

  local namespace=alias_completion::

  # Extract the name of the completion function from a string that
  # looks like: something -F function_name something
  # First strip the beginning of the string up to the function name by
  # removing "* -F " from the front.
  local completion_function=${completion##* -F }
  # Then strip " *" from the end, leaving only the function name.
  completion_function=${completion_function%% *}

  # Try to prevent an infinite loop by not wrapping a function
  # generated by this function. This can happen when the user runs
  # this twice for an alias like ls='ls --color=auto' or alias l='ls'
  # and alias ls='l foo'
  [[ "${completion_function#$namespace}" != $completion_function ]] && return 0

  local wrapper_name="${namespace}${alias_name}"

  eval "
function ${wrapper_name}() {
  ((COMP_CWORD+=$num_alias_arguments))
  args=( \"${alias_arguments}\" )
  COMP_WORDS=( $aliased_command \${args[@]} \${COMP_WORDS[@]:1} )
  $completion_function
  }
"

  # To create the new completion we use the old one with two
  # replacements:
  # 1) Replace the function with the wrapper.
  local new_completion=${completion/-F * /-F $wrapper_name }
  # 2) Replace the command being completed with the alias.
  new_completion="${new_completion% *} $alias_name"

  eval "$new_completion"
}

# For each defined alias, extract the necessary elements and use them
# to call wrap_alias.
eval "$(alias -p | sed -e 's/alias \([^=][^=]*\)='\''\([^ ][^ ]*\) *\(.*\)'\''/wrap_alias \1 \2 '\''\3'\'' /')"

unset wrap_alias

export MANPATH=/usr/share/man:/usr/local/man:$MANPATH
[[ -s "$HOME/.rvm/scripts/rvm" ]] && . "$HOME/.rvm/scripts/rvm" # Load RVM function


[[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm" # Load RVM into a shell session *as a function*


export EC2_HOME=~/.ec2
export EC2_PRIVATE_KEY=`ls $EC2_HOME/pk-*.pem`
export EC2_CERT=`ls $EC2_HOME/cert-*.pem`
export JAVA_HOME=/System/Library/Frameworks/JavaVM.framework/Home/
